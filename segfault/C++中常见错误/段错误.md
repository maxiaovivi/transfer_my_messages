段错误是C++中常见的错误，并且会直接引起程序崩溃，导致扫地机停机。这对于我们来说是严重问题。

在下边会记录一些规划器中造成段错误的原因。 特别是编译可以通过的段错误。

## 过流段错误 —— 迭代器越界


### 问题分析
问题产生原因为Task 中 `overcurrent_obstacle` 被清除了，last 队列比其长之后照常的迭代器越界。 而在某些项目中不会清除过流障碍物，所以不会出现这个现象。
![[Pasted image 20240507090722.png]]
![[Pasted image 20240507090833.png]]
![[Pasted image 20240506191654.png]]

本质原因是由于first迭代器指针超过了last指针，库函数会自己抛出异常，但是异常没人捕获，所以就会挂掉。

一个简单的小实验，来说明这个问题。 对于insert_deque来说，其长度为4，当迭代器指针没有超过尾指针前
![[BC306BBC-655E-4530-8D52-42C367532C21.png]]![[522C61A0-8374-4afc-A15E-A9C799417C95.png]]
在STL库中存在对头尾指针的比较函数，如果发现头指针大于尾指针，会直接抛出异常。 因此，在没有异常捕获的情况下，必须要要保证指针的正确性。  而在有些平台的SDK中并不会进行判断并抛出异常。而是等到错误访问以后，直接给出系统级的错误比如SIGSEGV信号。

![[Dingtalk_20240506193625.jpg]]

### 解决方案
在对指针和迭代器操作的时候尽量要避免在指针上作加减法。 你无法保证某个队列是否在你需要的时候被clear了导致不够长，或者需要用其size作为依据的时候没有更新。

## 访问未给出的变量

### 问题
这种问题常见于在Task 或者 Obs 中取值使用会发生。 当Obs 中值还尚未给出时就进行获取则会出现刚情况。   例如在Navigation 初始化时就从 Slam Obs中获取栅格分辨率， 则概率出现段错误。 因为这与 该次初始化时机有关。
### 如何避免
避免在系统启动时就立刻取获取外部变量。 通过协调调用逻辑，保证该处有值。 没有办法加入保护，因为声明了该指针，你不知道这处内存的情况是什么。


## 头文件未给出 return 值
我们常使用get 方法来简单获取其他类的成员变量。例如 bool getFlag() {return m_flag} 。 但由于头文件不编译，所以bool getFlag(){} 也可以编译通过，因此调用则会段错误。
### 避免方案
头文件中实现的公有类一定要检测返回变量是否有效。
